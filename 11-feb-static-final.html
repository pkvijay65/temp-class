<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11th Feb: Static & Final Keywords</title>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --bg-table-header: #2d2d44;
            --text-primary: #eee;
            --text-secondary: #888;
            --border-color: #444;
            --hidden-cell-bg: #3d3d5c;
            --hidden-cell-hover: #4d4d6c;
            --quiz-bg: #2d132c;
            --quiz-option-bg: #1a1a2e;
            --quiz-option-hover: #3d3d5c;
            --discuss-bg: #1e3a5f;
            --gotcha-bg: #3d1a1a;
            --key-point-bg: #1a3d1a;
            --comparison-bg: #0f0f23;
            --nav-bg: #333;
            --nav-hover: #555;
        }

        body.light-theme {
            --bg-primary: #f0f2f5;
            --bg-secondary: #ffffff;
            --bg-code: #2d2d2d;
            --bg-table-header: #e8e8e8;
            --text-primary: #1a1a1a;
            --text-secondary: #555;
            --border-color: #d0d0d0;
            --hidden-cell-bg: #d8d8d8;
            --hidden-cell-hover: #c8c8c8;
            --quiz-bg: #fce4ec;
            --quiz-option-bg: #fff;
            --quiz-option-hover: #f5f5f5;
            --discuss-bg: #e3f2fd;
            --gotcha-bg: #ffebee;
            --key-point-bg: #e8f5e9;
            --comparison-bg: #f5f5f5;
            --nav-bg: #e0e0e0;
            --nav-hover: #d0d0d0;
            --code-text: #e0e0e0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: var(--bg-primary); color: var(--text-primary); padding: 20px; transition: all 0.3s; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: #00d4ff; margin-bottom: 5px; }
        .subtitle { text-align: center; color: var(--text-secondary); margin-bottom: 30px; }
        h2 { color: #ffd93d; border-bottom: 2px solid #ffd93d; padding-bottom: 10px; margin: 30px 0 20px; }
        h3 { color: #50fa7b; margin: 20px 0 10px; }

        .progress { position: fixed; top: 0; left: 0; height: 4px; background: linear-gradient(90deg, #00d4ff, #50fa7b); transition: width 0.3s; z-index: 1000; }
        .theme-toggle { position: fixed; top: 15px; right: 15px; background: var(--nav-bg); border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 18px; z-index: 1001; }

        .section { display: none; background: var(--bg-secondary); padding: 25px; border-radius: 10px; margin-bottom: 20px; border: 1px solid var(--border-color); }
        .section.visible { display: block; }

        pre { background: var(--bg-code); padding: 15px; border-radius: 8px; overflow-x: auto; margin: 15px 0; border-left: 4px solid #00d4ff; }
        code { font-family: 'Fira Code', 'Consolas', monospace; font-size: 14px; }
        body.light-theme pre code { color: var(--code-text); }
        .keyword { color: #ff79c6; }
        .type { color: #8be9fd; }
        .string { color: #f1fa8c; }
        .comment { color: #6272a4; }
        .annotation { color: #50fa7b; }
        .highlight { background: #ffd93d33; padding: 2px 6px; border-radius: 3px; }

        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { padding: 12px; text-align: left; border: 1px solid var(--border-color); }
        th { background: var(--bg-table-header); color: #ffd93d; }
        tr:nth-child(even) { background: rgba(255,255,255,0.02); }

        .clickable-row { cursor: pointer; }
        .clickable-row:hover .hidden-cell { background: var(--hidden-cell-hover); }
        .hidden-cell { background: var(--hidden-cell-bg); text-align: center; color: var(--text-secondary); transition: all 0.3s; }
        .hidden-cell.revealed { background: transparent; color: var(--text-primary); text-align: left; }
        .table-reset-btn { margin-top: 10px; padding: 8px 16px; background: var(--nav-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 5px; cursor: pointer; }

        .quiz { background: var(--quiz-bg); padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #ff6b6b; }
        .quiz-q { font-weight: bold; margin-bottom: 15px; color: #ff6b6b; }
        .quiz-options { display: flex; flex-direction: column; gap: 10px; }
        .quiz-options label { background: var(--quiz-option-bg); padding: 12px 15px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; display: flex; align-items: center; gap: 10px; }
        .quiz-options label:hover { background: var(--quiz-option-hover); border-color: #ff6b6b; }
        .quiz-options input { accent-color: #ff6b6b; width: 18px; height: 18px; }
        .quiz-answer { margin-top: 15px; padding: 15px; border-radius: 8px; display: none; font-weight: bold; }
        .quiz-answer.correct { background: #1a3d1a; color: #50fa7b; border: 1px solid #50fa7b; }
        .quiz-answer.incorrect { background: #3d1a1a; color: #ff6b6b; border: 1px solid #ff6b6b; }

        .discuss { background: var(--discuss-bg); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #00d4ff; font-style: italic; }
        .key-point { background: var(--key-point-bg); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #50fa7b; }
        .gotcha { background: var(--gotcha-bg); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ff6b6b; }
        .gotcha-title { font-weight: bold; color: #ff6b6b; margin-bottom: 10px; }
        .gotcha-answer { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; display: none; }
        .gotcha-answer.revealed { display: block; }
        .gotcha-reveal-btn { background: #ff6b6b; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-top: 10px; }
        .gotcha-reveal-btn.revealed { background: #666; }

        .hideable { margin: 15px 0; }
        .hideable-btn { background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .hideable-btn.revealed { background: #666; color: white; }
        .hideable-content { display: none; margin-top: 10px; padding: 15px; background: var(--comparison-bg); border-radius: 8px; border: 1px solid var(--border-color); }
        .hideable-content.revealed { display: block; }

        .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .comparison > div { background: var(--comparison-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); }

        .nav { position: fixed; bottom: 0; left: 0; right: 0; background: var(--nav-bg); padding: 15px; display: flex; justify-content: center; gap: 15px; z-index: 100; }
        .nav button { background: #00d4ff; color: #1a1a2e; border: none; padding: 12px 25px; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; transition: all 0.2s; }
        .nav button:hover { background: #00a8cc; transform: translateY(-2px); }

        .topic-divider { background: linear-gradient(90deg, #ff6b6b, #ffd93d, #50fa7b); height: 4px; margin: 40px 0; border-radius: 2px; }
    </style>
</head>
<body class="light-theme">
    <div class="progress" id="progress"></div>
    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Light/Dark Theme">ğŸŒ“</button>
    <div class="container">
        <h1>11th Feb: Static & Final Keywords</h1>
        <p class="subtitle">Backend LLD | OOP Concepts</p>

        <!-- Section 1: Recap Quiz -->
        <div class="section visible" id="s1">
            <h2>Quick Recap: Abstract Classes & Interfaces</h2>
            <div class="discuss">Let's test your understanding from last class with some tricky questions...</div>

            <div class="quiz">
                <div class="quiz-q">Q1: Which statement is TRUE about abstract classes?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q1" value="a" onclick="checkQuiz(this, false)"> Abstract class cannot have a constructor</label>
                    <label><input type="radio" name="q1" value="b" onclick="checkQuiz(this, false)"> All methods in abstract class must be abstract</label>
                    <label><input type="radio" name="q1" value="c" onclick="checkQuiz(this, true)"> Abstract class can have both abstract and concrete methods</label>
                    <label><input type="radio" name="q1" value="d" onclick="checkQuiz(this, false)"> Abstract class can be instantiated using new keyword</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="quiz">
                <div class="quiz-q">Q2: What happens here?</div>
                <pre><code><span class="keyword">interface</span> <span class="type">A</span> { <span class="keyword">void</span> show(); }
<span class="keyword">interface</span> <span class="type">B</span> { <span class="keyword">void</span> show(); }
<span class="keyword">class</span> <span class="type">C</span> <span class="keyword">implements</span> <span class="type">A</span>, <span class="type">B</span> {
    <span class="keyword">public void</span> show() { System.out.println(<span class="string">"Hello"</span>); }
}</code></pre>
                <div class="quiz-options">
                    <label><input type="radio" name="q2" value="a" onclick="checkQuiz(this, false)"> Compilation error - ambiguous method</label>
                    <label><input type="radio" name="q2" value="b" onclick="checkQuiz(this, true)"> Compiles fine - one implementation satisfies both interfaces</label>
                    <label><input type="radio" name="q2" value="c" onclick="checkQuiz(this, false)"> Runtime error</label>
                    <label><input type="radio" name="q2" value="d" onclick="checkQuiz(this, false)"> Must implement show() twice</label>
                </div>
                <div class="quiz-answer"></div>
            </div>
        </div>

        <!-- Section 2: Recap Quiz Continued -->
        <div class="section" id="s2">
            <h2>Recap Quiz (Continued)</h2>

            <div class="quiz">
                <div class="quiz-q">Q3: What's the output?</div>
                <pre><code><span class="keyword">abstract class</span> <span class="type">Parent</span> {
    <span class="type">Parent</span>() { System.out.println(<span class="string">"Parent"</span>); }
}
<span class="keyword">class</span> <span class="type">Child</span> <span class="keyword">extends</span> <span class="type">Parent</span> {
    <span class="type">Child</span>() { System.out.println(<span class="string">"Child"</span>); }
}
<span class="keyword">new</span> <span class="type">Child</span>();</code></pre>
                <div class="quiz-options">
                    <label><input type="radio" name="q3" value="a" onclick="checkQuiz(this, false)"> Child</label>
                    <label><input type="radio" name="q3" value="b" onclick="checkQuiz(this, true)"> Parent, Child</label>
                    <label><input type="radio" name="q3" value="c" onclick="checkQuiz(this, false)"> Compilation error - can't call abstract constructor</label>
                    <label><input type="radio" name="q3" value="d" onclick="checkQuiz(this, false)"> Child, Parent</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="quiz">
                <div class="quiz-q">Q4: Which is valid in an interface (Pre-Java 8)?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q4" value="a" onclick="checkQuiz(this, false)"> private void method();</label>
                    <label><input type="radio" name="q4" value="b" onclick="checkQuiz(this, false)"> int x = 10; (instance variable)</label>
                    <label><input type="radio" name="q4" value="c" onclick="checkQuiz(this, true)"> int MAX = 100; (constant)</label>
                    <label><input type="radio" name="q4" value="d" onclick="checkQuiz(this, false)"> Interface() { } (constructor)</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="quiz">
                <div class="quiz-q">Q5: Can an abstract class implement an interface without implementing its methods?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q5" value="a" onclick="checkQuiz(this, true)"> Yes - abstract classes can leave interface methods unimplemented</label>
                    <label><input type="radio" name="q5" value="b" onclick="checkQuiz(this, false)"> No - must implement all methods</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="quiz">
                <div class="quiz-q">Q6: What's true about interface variables?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q6" value="a" onclick="checkQuiz(this, false)"> They can be modified after initialization</label>
                    <label><input type="radio" name="q6" value="b" onclick="checkQuiz(this, true)"> They are implicitly public static final</label>
                    <label><input type="radio" name="q6" value="c" onclick="checkQuiz(this, false)"> They can be private</label>
                    <label><input type="radio" name="q6" value="d" onclick="checkQuiz(this, false)"> They are instance variables</label>
                </div>
                <div class="quiz-answer"></div>
            </div>
        </div>

        <div class="topic-divider"></div>

        <!-- ==================== STATIC KEYWORD ==================== -->

        <!-- Section 3: Static Introduction -->
        <div class="section" id="s3">
            <h2>Part 1: The Static Keyword</h2>
            <h3>The Problem: Shared Data Across Instances</h3>

            <div class="discuss">You're building a user tracking system...</div>

            <pre><code><span class="keyword">class</span> <span class="type">User</span> {
    <span class="type">String</span> name;
    <span class="keyword">int</span> userCount = 0;  <span class="comment">// Track total users</span>

    <span class="keyword">public</span> User(<span class="type">String</span> name) {
        <span class="keyword">this</span>.name = name;
        userCount++;
    }
}

<span class="type">User</span> u1 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Alice"</span>);
<span class="type">User</span> u2 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Bob"</span>);
<span class="type">User</span> u3 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Charlie"</span>);

System.out.println(u1.userCount);  <span class="comment">// ???</span>
System.out.println(u2.userCount);
System.out.println(u3.userCount);</code></pre>

            <div class="quiz">
                <div class="quiz-q">What does each userCount print?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q7" value="a" onclick="checkQuiz(this, true)"> 1, 1, 1</label>
                    <label><input type="radio" name="q7" value="b" onclick="checkQuiz(this, false)"> 3, 3, 3</label>
                    <label><input type="radio" name="q7" value="c" onclick="checkQuiz(this, false)"> 1, 2, 3</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="key-point">
                <strong>Problem:</strong> Each object has its OWN copy of userCount. We need a variable shared by ALL instances!
            </div>
        </div>

        <!-- Section 4: Static Variables -->
        <div class="section" id="s4">
            <h2>Static Variables (Class Variables)</h2>

            <pre><code><span class="keyword">class</span> <span class="type">User</span> {
    <span class="type">String</span> name;                  <span class="comment">// Instance variable</span>
    <span class="keyword">static int</span> userCount = 0;     <span class="comment">// Static variable - ONE copy for ALL</span>

    <span class="keyword">public</span> User(<span class="type">String</span> name) {
        <span class="keyword">this</span>.name = name;
        userCount++;  <span class="comment">// Same variable for ALL</span>
    }
}

<span class="type">User</span> u1 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Alice"</span>);    <span class="comment">// userCount = 1</span>
<span class="type">User</span> u2 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Bob"</span>);      <span class="comment">// userCount = 2</span>
<span class="type">User</span> u3 = <span class="keyword">new</span> <span class="type">User</span>(<span class="string">"Charlie"</span>); <span class="comment">// userCount = 3</span>

System.out.println(<span class="type">User</span>.userCount);  <span class="comment">// 3 - access via class name!</span></code></pre>

            <h3>Memory Layout</h3>
            <pre style="text-align: center; background: #1e1e1e; color: #e0e0e0;"><code>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    <span style="color: #ff6b6b;">JVM MEMORY</span>                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   <span style="color: #ffd93d;">METHOD AREA</span>        â”‚            <span style="color: #50fa7b;">HEAP</span>                    â”‚
â”‚   (Class Data)      â”‚         (Objects)                 â”‚
â”‚                     â”‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ User.class    â”‚  â”‚  â”‚ u1      â”‚  â”‚ u2      â”‚        â”‚
â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  â”‚  â”‚ name:   â”‚  â”‚ name:   â”‚        â”‚
â”‚  â”‚ <span style="color: #8be9fd;">userCount: 3</span> â”‚  â”‚  â”‚ "Alice" â”‚  â”‚ "Bob"   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                     â”‚                                   â”‚
â”‚  <span style="color: #8be9fd;">ONE copy shared</span>     â”‚  <span style="color: #50fa7b;">Each object has own copy</span>         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

            <div class="comparison">
                <div>
                    <h3>Instance Variable</h3>
                    <ul>
                        <li>One copy per object</li>
                        <li>Stored in Heap</li>
                        <li>Access via object reference</li>
                    </ul>
                </div>
                <div>
                    <h3>Static Variable</h3>
                    <ul>
                        <li>One copy per class</li>
                        <li>Stored in Method Area</li>
                        <li>Access via class name</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Section 5: Static Methods -->
        <div class="section" id="s5">
            <h2>Static Methods</h2>

            <div class="discuss">Methods that belong to the class, not instances...</div>

            <pre><code><span class="keyword">class</span> <span class="type">MathUtils</span> {
    <span class="keyword">public static int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
        <span class="keyword">return</span> a + b;
    }

    <span class="keyword">public static int</span> max(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
        <span class="keyword">return</span> a > b ? a : b;
    }
}

<span class="comment">// Call WITHOUT creating an object!</span>
<span class="keyword">int</span> sum = <span class="type">MathUtils</span>.add(5, 3);
<span class="keyword">int</span> maximum = <span class="type">MathUtils</span>.max(10, 7);</code></pre>

            <h3>Static Method Restrictions</h3>
            <pre><code><span class="keyword">class</span> <span class="type">User</span> {
    <span class="type">String</span> name;              <span class="comment">// Instance variable</span>
    <span class="keyword">static int</span> count;         <span class="comment">// Static variable</span>

    <span class="keyword">static void</span> printInfo() {
        System.out.println(count);   <span class="comment">// OK - static can access static</span>
        System.out.println(name);    <span class="comment">// ERROR! No object reference</span>
        System.out.println(<span class="keyword">this</span>);    <span class="comment">// ERROR! 'this' not available</span>
    }
}</code></pre>

            <div class="key-point">
                <strong>The Rule:</strong><br>
                Static â†’ Static: âœ… OK<br>
                Static â†’ Instance: âŒ NOT OK (no object context)<br>
                Instance â†’ Static: âœ… OK<br>
                Instance â†’ Instance: âœ… OK
            </div>
        </div>

        <!-- Section 6: Static & Polymorphism -->
        <div class="section" id="s6">
            <h2>Static & Polymorphism (Method Hiding)</h2>

            <div class="discuss">Can we override static methods? Let's see...</div>

            <pre><code><span class="keyword">class</span> <span class="type">Parent</span> {
    <span class="keyword">static void</span> greet() { System.out.println(<span class="string">"Parent"</span>); }
    <span class="keyword">void</span> hello() { System.out.println(<span class="string">"Parent hello"</span>); }
}

<span class="keyword">class</span> <span class="type">Child</span> <span class="keyword">extends</span> <span class="type">Parent</span> {
    <span class="keyword">static void</span> greet() { System.out.println(<span class="string">"Child"</span>); }  <span class="comment">// Hiding, not overriding!</span>
    <span class="keyword">void</span> hello() { System.out.println(<span class="string">"Child hello"</span>); }   <span class="comment">// True overriding</span>
}

<span class="type">Parent</span> p = <span class="keyword">new</span> <span class="type">Child</span>();
p.greet();   <span class="comment">// ???</span>
p.hello();   <span class="comment">// ???</span></code></pre>

            <div class="quiz">
                <div class="quiz-q">What's the output?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q8" value="a" onclick="checkQuiz(this, false)"> Child, Child</label>
                    <label><input type="radio" name="q8" value="b" onclick="checkQuiz(this, true)"> Parent, Child hello</label>
                    <label><input type="radio" name="q8" value="c" onclick="checkQuiz(this, false)"> Parent, Parent hello</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="key-point">
                <strong>Method Hiding vs Overriding:</strong><br>
                <strong>Static methods:</strong> Resolved at COMPILE time based on reference type â†’ No polymorphism!<br>
                <strong>Instance methods:</strong> Resolved at RUNTIME based on actual object â†’ Polymorphism!
            </div>

            <table>
                <tr><th>Feature</th><th>Static Method</th><th>Instance Method</th></tr>
                <tr><td>Binding</td><td>Compile-time (early)</td><td>Runtime (late)</td></tr>
                <tr><td>@Override</td><td>Not applicable</td><td>Can use</td></tr>
                <tr><td>Term</td><td>Method Hiding</td><td>Method Overriding</td></tr>
                <tr><td>Polymorphism</td><td>No</td><td>Yes</td></tr>
            </table>
        </div>

        <!-- Section 7: Static in Abstract Class -->
        <div class="section" id="s7">
            <h2>Static in Abstract Class</h2>

            <div class="discuss">Can abstract classes have static members?</div>

            <pre><code><span class="keyword">abstract class</span> <span class="type">Database</span> {
    <span class="keyword">static</span> <span class="type">String</span> driver = <span class="string">"JDBC"</span>;  <span class="comment">// Static variable - OK!</span>

    <span class="keyword">static void</span> loadDriver() {         <span class="comment">// Static method - OK!</span>
        System.out.println(<span class="string">"Loading "</span> + driver);
    }

    <span class="keyword">abstract void</span> connect();          <span class="comment">// Abstract method</span>
}

<span class="comment">// Access static members without instantiation</span>
System.out.println(<span class="type">Database</span>.driver);
<span class="type">Database</span>.loadDriver();</code></pre>

            <div class="quiz">
                <div class="quiz-q">Can a static method be abstract?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q9" value="a" onclick="checkQuiz(this, false)"> Yes</label>
                    <label><input type="radio" name="q9" value="b" onclick="checkQuiz(this, true)"> No - static methods cannot be overridden, so can't be abstract</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="key-point">
                <strong>Abstract class static members:</strong><br>
                âœ… Static variables - allowed<br>
                âœ… Static methods (with body) - allowed<br>
                âŒ Static abstract methods - NOT allowed (contradiction!)
            </div>
        </div>

        <!-- Section 8: Static in Interface -->
        <div class="section" id="s8">
            <h2>Static in Interface</h2>

            <h3>Static Variables in Interface</h3>
            <pre><code><span class="keyword">interface</span> <span class="type">Constants</span> {
    <span class="keyword">int</span> MAX_SIZE = 100;        <span class="comment">// implicitly public static final</span>
    <span class="type">String</span> DEFAULT = <span class="string">"N/A"</span>;   <span class="comment">// implicitly public static final</span>
}

<span class="comment">// Access via interface name</span>
System.out.println(<span class="type">Constants</span>.MAX_SIZE);  <span class="comment">// 100</span>

<span class="comment">// Cannot modify!</span>
<span class="type">Constants</span>.MAX_SIZE = 200;  <span class="comment">// ERROR! final variable</span></code></pre>

            <div class="key-point">
                <strong>All interface variables are implicitly:</strong><br>
                <code>public</code> - accessible everywhere<br>
                <code>static</code> - belongs to interface, not instance<br>
                <code>final</code> - cannot be changed (constant)
            </div>

            <h3>Static Methods in Interface (Java 8+)</h3>
            <pre><code><span class="keyword">interface</span> <span class="type">StringUtils</span> {
    <span class="comment">// Static method in interface - Java 8+</span>
    <span class="keyword">static boolean</span> isEmpty(<span class="type">String</span> s) {
        <span class="keyword">return</span> s == <span class="keyword">null</span> || s.length() == 0;
    }

    <span class="keyword">static</span> <span class="type">String</span> reverse(<span class="type">String</span> s) {
        <span class="keyword">return new</span> StringBuilder(s).reverse().toString();
    }
}

<span class="comment">// Call on interface name (NOT on implementing class!)</span>
<span class="type">StringUtils</span>.isEmpty(<span class="string">""</span>);       <span class="comment">// true</span>
<span class="type">StringUtils</span>.reverse(<span class="string">"hello"</span>); <span class="comment">// "olleh"</span></code></pre>

            <div class="gotcha">
                <div class="gotcha-title">GOTCHA: Interface static methods are NOT inherited!</div>
                <pre><code><span class="keyword">interface</span> <span class="type">A</span> {
    <span class="keyword">static void</span> foo() { System.out.println(<span class="string">"A"</span>); }
}
<span class="keyword">class</span> <span class="type">B</span> <span class="keyword">implements</span> <span class="type">A</span> { }

<span class="type">A</span>.foo();  <span class="comment">// OK</span>
<span class="type">B</span>.foo();  <span class="comment">// ERROR! Not inherited</span></code></pre>
                <button class="gotcha-reveal-btn" onclick="revealGotcha(this)">Why?</button>
                <div class="gotcha-answer">
                    Interface static methods belong ONLY to the interface. Unlike class static methods, they are not inherited by implementing classes. This prevents ambiguity when a class implements multiple interfaces with same static method names.
                </div>
            </div>
        </div>

        <!-- Section 9: Static Blocks -->
        <div class="section" id="s9">
            <h2>Static Blocks</h2>

            <div class="discuss">Code that runs ONCE when the class is first loaded...</div>

            <pre><code><span class="keyword">class</span> <span class="type">Config</span> {
    <span class="keyword">static</span> <span class="type">String</span> dbUrl;
    <span class="keyword">static</span> <span class="type">String</span> apiKey;

    <span class="comment">// Static block - runs when class loads</span>
    <span class="keyword">static</span> {
        System.out.println(<span class="string">"Loading config..."</span>);
        dbUrl = System.getenv(<span class="string">"DB_URL"</span>);
        apiKey = System.getenv(<span class="string">"API_KEY"</span>);
        System.out.println(<span class="string">"Config loaded!"</span>);
    }
}

<span class="comment">// First access triggers static block</span>
System.out.println(<span class="type">Config</span>.dbUrl);</code></pre>

            <h3>Execution Order</h3>
            <pre><code><span class="keyword">class</span> <span class="type">Demo</span> {
    <span class="keyword">static</span> { System.out.println(<span class="string">"1. Static block"</span>); }
    { System.out.println(<span class="string">"2. Instance block"</span>); }
    Demo() { System.out.println(<span class="string">"3. Constructor"</span>); }
}

<span class="keyword">new</span> <span class="type">Demo</span>();
<span class="keyword">new</span> <span class="type">Demo</span>();</code></pre>

            <div class="quiz">
                <div class="quiz-q">What's printed?</div>
                <div class="quiz-options">
                    <label><input type="radio" name="q10" value="a" onclick="checkQuiz(this, true)"> 1, 2, 3, 2, 3</label>
                    <label><input type="radio" name="q10" value="b" onclick="checkQuiz(this, false)"> 1, 2, 3, 1, 2, 3</label>
                    <label><input type="radio" name="q10" value="c" onclick="checkQuiz(this, false)"> 2, 3, 2, 3</label>
                </div>
                <div class="quiz-answer"></div>
            </div>

            <div class="key-point">
                <strong>Execution Order:</strong><br>
                1. Static blocks (ONCE when class loads)<br>
                2. Instance blocks (each time object created)<br>
                3. Constructor (each time object created)
            </div>
        </div>

        <!-- Section 10: Static Nested Classes -->
        <div class="section" id="s10">
            <h2>Static Nested Classes</h2>

            <pre><code><span class="keyword">class</span> <span class="type">Outer</span> {
    <span class="type">String</span> instanceVar = <span class="string">"instance"</span>;
    <span class="keyword">static</span> <span class="type">String</span> staticVar = <span class="string">"static"</span>;

    <span class="comment">// Non-static inner class</span>
    <span class="keyword">class</span> <span class="type">Inner</span> {
        <span class="keyword">void</span> show() {
            System.out.println(instanceVar);  <span class="comment">// OK</span>
            System.out.println(staticVar);    <span class="comment">// OK</span>
        }
    }

    <span class="comment">// Static nested class</span>
    <span class="keyword">static class</span> <span class="type">StaticNested</span> {
        <span class="keyword">void</span> show() {
            <span class="comment">// System.out.println(instanceVar);  // ERROR!</span>
            System.out.println(staticVar);    <span class="comment">// OK</span>
        }
    }
}

<span class="comment">// Creating instances</span>
<span class="type">Outer</span> outer = <span class="keyword">new</span> <span class="type">Outer</span>();
<span class="type">Outer</span>.<span class="type">Inner</span> inner = outer.<span class="keyword">new</span> <span class="type">Inner</span>();           <span class="comment">// Needs outer instance</span>
<span class="type">Outer</span>.<span class="type">StaticNested</span> nested = <span class="keyword">new</span> <span class="type">Outer</span>.<span class="type">StaticNested</span>(); <span class="comment">// No outer needed</span></code></pre>

            <div class="key-point">
                <strong>Use static nested class when:</strong><br>
                - Doesn't need access to outer class instance members<br>
                - Logically belongs to outer class but is independent<br>
                - Example: Builder pattern (<code>User.Builder</code>)
            </div>
        </div>

        <div class="topic-divider"></div>

        <!-- ==================== FINAL KEYWORD ==================== -->

        <!-- Section 11: Final Keyword Introduction -->
        <div class="section" id="s11">
            <h2>Part 2: The Final Keyword</h2>
            <div class="discuss">Final means "cannot be changed"... but what exactly can be final?</div>

            <h3>Three Uses of Final</h3>
            <table>
                <tr><th>Applied to</th><th>Meaning</th></tr>
                <tr><td>Variable</td><td>Value cannot be changed (constant)</td></tr>
                <tr><td>Method</td><td>Cannot be overridden by subclass</td></tr>
                <tr><td>Class</td><td>Cannot be extended (no subclasses)</td></tr>
            </table>
        </div>

        <!-- Section 12: Final Variables -->
        <div class="section" id="s12">
            <h2>Final Variables</h2>

            <pre><code><span class="keyword">class</span> <span class="type">Example</span> {
    <span class="keyword">final int</span> MAX = 100;           <span class="comment">// Must initialize here</span>
    <span class="keyword">final int</span> value;               <span class="comment">// OR in constructor</span>

    Example(<span class="keyword">int</span> v) {
        <span class="keyword">this</span>.value = v;              <span class="comment">// OK - first assignment</span>
        <span class="comment">// this.value = 10;           // ERROR! Already assigned</span>
    }

    <span class="keyword">void</span> test() {
        <span class="comment">// MAX = 200;                 // ERROR! Cannot modify final</span>

        <span class="keyword">final int</span> localVar = 5;      <span class="comment">// Final local variable</span>
        <span class="comment">// localVar = 10;             // ERROR!</span>
    }
}</code></pre>

            <h3>Final with Reference Types</h3>
            <pre><code><span class="keyword">final</span> <span class="type">List</span> list = <span class="keyword">new</span> <span class="type">ArrayList</span>();

<span class="comment">// list = new ArrayList();  // ERROR! Can't reassign reference</span>

list.add(<span class="string">"Hello"</span>);           <span class="comment">// OK! Can modify object's contents</span>
list.add(<span class="string">"World"</span>);           <span class="comment">// OK!</span></code></pre>

            <div class="key-point">
                <strong>Final reference:</strong><br>
                âŒ Cannot point to different object<br>
                âœ… CAN modify object's internal state
            </div>
        </div>

        <!-- Section 13: Final Methods -->
        <div class="section" id="s13">
            <h2>Final Methods</h2>

            <pre><code><span class="keyword">class</span> <span class="type">BankAccount</span> {
    <span class="keyword">private double</span> balance;

    <span class="comment">// Final method - cannot be overridden</span>
    <span class="keyword">public final double</span> getBalance() {
        <span class="keyword">return</span> balance;
    }

    <span class="comment">// Can be overridden</span>
    <span class="keyword">public void</span> deposit(<span class="keyword">double</span> amount) {
        balance += amount;
    }
}

<span class="keyword">class</span> <span class="type">SavingsAccount</span> <span class="keyword">extends</span> <span class="type">BankAccount</span> {
    <span class="comment">// ERROR! Cannot override final method</span>
    <span class="comment">// public double getBalance() { return 0; }</span>

    <span class="annotation">@Override</span>
    <span class="keyword">public void</span> deposit(<span class="keyword">double</span> amount) {
        <span class="comment">// OK - add interest logic</span>
        <span class="keyword">super</span>.deposit(amount * 1.05);
    }
}</code></pre>

            <div class="key-point">
                <strong>When to use final methods:</strong><br>
                - Security-critical methods (authentication, validation)<br>
                - Methods whose behavior should never change<br>
                - Template method pattern (final template, abstract steps)
            </div>
        </div>

        <!-- Section 14: Final Classes -->
        <div class="section" id="s14">
            <h2>Final Classes</h2>

            <pre><code><span class="keyword">final class</span> <span class="type">ImmutableConfig</span> {
    <span class="keyword">private final</span> <span class="type">String</span> dbUrl;
    <span class="keyword">private final int</span> port;

    <span class="keyword">public</span> ImmutableConfig(<span class="type">String</span> url, <span class="keyword">int</span> port) {
        <span class="keyword">this</span>.dbUrl = url;
        <span class="keyword">this</span>.port = port;
    }

    <span class="keyword">public</span> <span class="type">String</span> getDbUrl() { <span class="keyword">return</span> dbUrl; }
    <span class="keyword">public int</span> getPort() { <span class="keyword">return</span> port; }
}

<span class="comment">// ERROR! Cannot extend final class</span>
<span class="comment">// class ExtendedConfig extends ImmutableConfig { }</span></code></pre>

            <div class="discuss">Real-world final classes in Java:</div>
            <ul>
                <li><code>String</code> - immutability guarantee</li>
                <li><code>Integer, Double, Boolean</code> - wrapper classes</li>
                <li><code>Math</code> - utility class</li>
                <li><code>System</code> - security</li>
            </ul>

            <div class="key-point">
                <strong>When to use final class:</strong><br>
                - Immutable classes (security, thread-safety)<br>
                - Utility classes with only static methods<br>
                - Prevent inheritance for security reasons
            </div>
        </div>

        <!-- Section 15: Final & Static Together -->
        <div class="section" id="s15">
            <h2>Final + Static = Constants</h2>

            <pre><code><span class="keyword">class</span> <span class="type">AppConstants</span> {
    <span class="comment">// Convention: UPPER_SNAKE_CASE for constants</span>
    <span class="keyword">public static final</span> <span class="type">String</span> APP_NAME = <span class="string">"MyApp"</span>;
    <span class="keyword">public static final int</span> MAX_CONNECTIONS = 100;
    <span class="keyword">public static final double</span> PI = 3.14159;

    <span class="comment">// Blank final - must initialize in static block</span>
    <span class="keyword">public static final</span> <span class="type">String</span> DB_URL;

    <span class="keyword">static</span> {
        DB_URL = System.getenv(<span class="string">"DATABASE_URL"</span>);
    }

    <span class="comment">// Private constructor - prevent instantiation</span>
    <span class="keyword">private</span> AppConstants() { }
}

<span class="comment">// Usage</span>
System.out.println(<span class="type">AppConstants</span>.APP_NAME);
System.out.println(<span class="type">AppConstants</span>.MAX_CONNECTIONS);</code></pre>

            <div class="key-point">
                <strong>static final</strong> = True constant<br>
                - One copy shared by all<br>
                - Cannot be modified<br>
                - Loaded at class loading time
            </div>
        </div>

        <!-- Section 16: Interview Gotchas -->
        <div class="section" id="s16">
            <h2>Interview Gotchas</h2>

            <div class="gotcha">
                <div class="gotcha-title">GOTCHA #1: Can we have static method in interface?</div>
                <button class="gotcha-reveal-btn" onclick="revealGotcha(this)">Show Answer</button>
                <div class="gotcha-answer">
                    <strong>Yes, since Java 8!</strong> But they're NOT inherited by implementing classes. Must call via interface name.
                </div>
            </div>

            <div class="gotcha">
                <div class="gotcha-title">GOTCHA #2: Can static method be overridden?</div>
                <button class="gotcha-reveal-btn" onclick="revealGotcha(this)">Show Answer</button>
                <div class="gotcha-answer">
                    <strong>No!</strong> Static methods are hidden, not overridden. They use compile-time binding based on reference type, not runtime binding.
                </div>
            </div>

            <div class="gotcha">
                <div class="gotcha-title">GOTCHA #3: Can final method be overloaded?</div>
                <button class="gotcha-reveal-btn" onclick="revealGotcha(this)">Show Answer</button>
                <div class="gotcha-answer">
                    <strong>Yes!</strong> Final prevents overriding (same signature in subclass), not overloading (different parameters in same class).
                </div>
            </div>

            <div class="gotcha">
                <div class="gotcha-title">GOTCHA #4: Can constructor be final?</div>
                <button class="gotcha-reveal-btn" onclick="revealGotcha(this)">Show Answer</button>
                <div class="gotcha-answer">
                    <strong>No!</strong> Constructors are not inherited, so there's nothing to prevent overriding. Final modifier is not allowed.
                </div>
            </div>

            <div class="gotcha">
                <div class="gotcha-title">GOTCHA #5: What's the difference between final and immutable?</div>
                <button class="gotcha-reveal-btn" onclick="revealGotcha(this)">Show Answer</button>
                <div class="gotcha-answer">
                    <strong>final:</strong> Reference cannot be reassigned<br>
                    <strong>immutable:</strong> Object's state cannot be changed<br>
                    <code>final List list = new ArrayList();</code> - list is final but NOT immutable (can add/remove elements)
                </div>
            </div>
        </div>

        <!-- Section 17: Summary -->
        <div class="section" id="s17">
            <h2>Summary</h2>

            <h3>Static Keyword</h3>
            <table>
                <tr><th>Feature</th><th>Description</th></tr>
                <tr><td>Static Variable</td><td>One copy for all instances, stored in Method Area</td></tr>
                <tr><td>Static Method</td><td>Called on class, can't access instance members</td></tr>
                <tr><td>Static Block</td><td>Runs once when class loads</td></tr>
                <tr><td>Static Nested Class</td><td>Doesn't need outer instance</td></tr>
                <tr><td>Static in Interface</td><td>Variables: always static final. Methods: Java 8+ (not inherited)</td></tr>
            </table>

            <h3>Final Keyword</h3>
            <table>
                <tr><th>Applied To</th><th>Effect</th></tr>
                <tr><td>Variable</td><td>Cannot be reassigned</td></tr>
                <tr><td>Method</td><td>Cannot be overridden</td></tr>
                <tr><td>Class</td><td>Cannot be extended</td></tr>
            </table>
        </div>

    </div>

    <div class="nav">
        <button onclick="showAll()">Show All</button>
        <button onclick="reset()">Reset</button>
        <button onclick="prev()">â† Prev</button>
        <button onclick="next()">Next â†’</button>
    </div>

    <script>
        let currentSection = 1;
        const totalSections = 17;

        function updateProgress() {
            const progress = (currentSection / totalSections) * 100;
            document.getElementById('progress').style.width = progress + '%';
        }

        function showSection(n, updateHash = true) {
            if (n >= 1 && n <= totalSections) {
                document.querySelectorAll('.section').forEach(s => s.classList.remove('visible'));
                document.getElementById('s' + n).classList.add('visible');
                currentSection = n;
                updateProgress();
                if (updateHash) {
                    history.pushState(null, '', '#s' + n);
                }
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function next() { showSection(currentSection + 1); }
        function prev() { showSection(currentSection - 1); }

        window.addEventListener('popstate', function() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#s')) {
                const sectionNum = parseInt(hash.substring(2));
                if (sectionNum >= 1 && sectionNum <= totalSections) {
                    showSection(sectionNum, false);
                }
            }
        });

        function loadFromHash() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#s')) {
                const sectionNum = parseInt(hash.substring(2));
                if (sectionNum >= 1 && sectionNum <= totalSections) {
                    showSection(sectionNum, false);
                    return;
                }
            }
            showSection(1, false);
        }

        function showAll() {
            document.querySelectorAll('.section').forEach(s => s.classList.add('visible'));
            document.getElementById('progress').style.width = '100%';
        }

        function reset() {
            document.querySelectorAll('.section').forEach((s, i) => {
                s.classList.toggle('visible', i === 0);
            });
            currentSection = 1;
            updateProgress();
            history.pushState(null, '', '#s1');
            document.querySelectorAll('.quiz-answer').forEach(a => {
                a.style.display = 'none';
                a.className = 'quiz-answer';
            });
            document.querySelectorAll('input[type="radio"]').forEach(r => r.checked = false);
            document.querySelectorAll('.gotcha-answer').forEach(a => a.classList.remove('revealed'));
            document.querySelectorAll('.gotcha-reveal-btn').forEach(b => {
                b.classList.remove('revealed');
                b.textContent = 'Show Answer';
            });
            document.querySelectorAll('.hideable-content').forEach(c => c.classList.remove('revealed'));
            document.querySelectorAll('.hideable-btn').forEach(b => b.classList.remove('revealed'));
            document.querySelectorAll('.hidden-cell').forEach(c => {
                c.classList.remove('revealed');
                c.textContent = '';
            });
            document.querySelectorAll('.clickable-row').forEach(r => r.classList.remove('revealed'));
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function checkQuiz(input, isCorrect) {
            const quiz = input.closest('.quiz');
            const answer = quiz.querySelector('.quiz-answer');
            answer.style.display = 'block';
            if (isCorrect) {
                answer.className = 'quiz-answer correct';
                answer.textContent = 'âœ“ Correct!';
            } else {
                answer.className = 'quiz-answer incorrect';
                answer.textContent = 'âœ— Try again!';
            }
        }

        function revealGotcha(btn) {
            const gotcha = btn.closest('.gotcha');
            const answer = gotcha.querySelector('.gotcha-answer');
            const isRevealed = answer.classList.contains('revealed');
            if (isRevealed) {
                answer.classList.remove('revealed');
                btn.classList.remove('revealed');
                btn.textContent = 'Show Answer';
            } else {
                answer.classList.add('revealed');
                btn.classList.add('revealed');
                btn.textContent = 'Hide Answer';
            }
        }

        function revealHideable(btn) {
            const hideable = btn.closest('.hideable');
            const content = hideable.querySelector('.hideable-content');
            content.classList.toggle('revealed');
            btn.classList.toggle('revealed');
        }

        function revealRow(row) {
            const cells = row.querySelectorAll('.hidden-cell');
            cells.forEach(cell => {
                if (!cell.classList.contains('revealed')) {
                    cell.textContent = cell.dataset.value;
                    cell.classList.add('revealed');
                }
            });
            row.classList.add('revealed');
        }

        function resetTable(tableId) {
            const table = document.getElementById(tableId);
            table.querySelectorAll('.hidden-cell').forEach(cell => {
                cell.classList.remove('revealed');
                cell.textContent = '';
            });
            table.querySelectorAll('.clickable-row').forEach(row => row.classList.remove('revealed'));
        }

        function toggleTheme() {
            document.body.classList.toggle('light-theme');
            localStorage.setItem('theme', document.body.classList.contains('light-theme') ? 'light' : 'dark');
        }

        // Initialize
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.body.classList.remove('light-theme');
        }
        loadFromHash();
        updateProgress();
    </script>
</body>
</html>
